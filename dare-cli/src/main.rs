mod clipboard;
mod command;

use std::{
    env, fs,
    io::{self, Read},
    path::PathBuf,
};

use clap::Parser;

use self::clipboard::*;
use command::*;
use dare::{Solutions, TableauWriter};

impl Shell {
    #[cfg(target_os = "windows")]
    pub const GUARD_COMMENT: &'static str =
        "# generated by dare completion DO NOT ALTER THIS COMMENT OR THE LINE BELOW";

    #[cfg(target_os = "linux")]
    pub const fn source(&self) -> &'static str {
        match self {
            Shell::Bash => include_str!(concat!(env!("OUT_DIR"), "/dare.bash")),
            Shell::Elvish => include_str!(concat!(env!("OUT_DIR"), "/dare.elv")),
            Shell::Fish => include_str!(concat!(env!("OUT_DIR"), "/dare.fish")),
            Shell::PowerShell => include_str!(concat!(env!("OUT_DIR"), "/_dare.ps1")),
            Shell::Zsh => include_str!(concat!(env!("OUT_DIR"), "/_dare")),
        }
    }

    #[cfg(target_os = "windows")]
    pub const fn source(&self) -> &'static str {
        match self {
            Shell::PowerShell => include_str!(concat!(env!("OUT_DIR"), "/_dare.ps1")),
        }
    }

    #[cfg(target_os = "macos")]
    pub const fn source(&self) -> &'static str {
        match self {
            Shell::Bash => include_str!(concat!(env!("OUT_DIR"), "/dare.bash")),
            Shell::Elvish => include_str!(concat!(env!("OUT_DIR"), "/dare.elv")),
            Shell::Fish => include_str!(concat!(env!("OUT_DIR"), "/dare.fish")),
            Shell::PowerShell => include_str!(concat!(env!("OUT_DIR"), "/_dare.ps1")),
            Shell::Zsh => include_str!(concat!(env!("OUT_DIR"), "/_dare")),
        }
    }

    #[cfg(target_os = "linux")]
    pub const fn file_name(&self) -> &'static str {
        match self {
            Shell::Bash => "dare.bash",
            Shell::Elvish => "dare.elv",
            Shell::Fish => "dare.fish",
            Shell::PowerShell => "_dare.ps1",
            Shell::Zsh => "_dare",
        }
    }

    #[cfg(target_os = "windows")]
    pub const fn file_name(&self) -> &'static str {
        match self {
            Shell::PowerShell => "Microsoft.PowerShell_profile.ps1",
        }
    }

    #[cfg(target_os = "macos")]
    pub const fn file_name(&self) -> &'static str {
        match self {
            Shell::Bash => "dare.bash",
            Shell::Elvish => "dare.elv",
            Shell::Fish => "dare.fish",
            Shell::PowerShell => "_dare.ps1",
            Shell::Zsh => "_dare",
        }
    }

    // TODO: This is a hack to get the path to the completions directory.
    //       It should be replaced with a proper solution.
    //
    //       To be completely honest, these paths are automatically generated by github-copilot.
    //       So i don't even know if they work, but the fish one seems to.
    pub fn target_dir(&self) -> PathBuf {
        #[cfg(target_os = "linux")]
        match self {
            Shell::Bash => "/etc/bash_completion.d".into(),
            Shell::Elvish => "/usr/share/elvish/site-functions".into(),
            Shell::Fish => "/usr/share/fish/vendor_completions.d".into(),
            Shell::PowerShell => {
                "/usr/share/powershell/Modules/Microsoft.PowerShell_profile".into()
            }
            Shell::Zsh => "/usr/share/zsh/site-functions".into(),
        }
        #[cfg(target_os = "windows")]
        match self {
            Shell::PowerShell => {
                let paths = env::var("PSModulePath").unwrap();
                env::split_paths(&paths)
                    .next()
                    .unwrap()
                    .parent()
                    .unwrap()
                    .into()
            }
        }
        #[cfg(target_os = "macos")]
        match self {
            Shell::Bash => "/usr/local/etc/bash_completion.d".into(),
            Shell::Elvish => "/usr/local/share/elvish/site-functions".into(),
            Shell::Fish => "/usr/local/share/fish/vendor_completions.d".into(),
            Shell::PowerShell => {
                "/usr/local/share/powershell/Modules/Microsoft.PowerShell_profile".into()
            }
            Shell::Zsh => "/usr/local/share/zsh/site-functions".into(),
        }
    }

    #[cfg(any(target_os = "linux", target_os = "macos"))]
    pub fn install(&self) -> Result<(), io::Error> {
        use std::io::Write;

        let target_dir = self.target_dir();

        fs::create_dir_all(&target_dir)?;
        let mut file = fs::File::create(target_dir.join(self.file_name()))?;
        file.write_all(self.source().as_bytes())?;

        Ok(())
    }

    #[cfg(target_os = "windows")]
    pub fn install(&self) -> Result<(), io::Error> {
        let target_dir = self.target_dir();
        let target_file = target_dir.join("dare_completions.ps1");
        let profile_file = target_dir.join(self.file_name());

        let mut contents = fs::read_to_string(&profile_file)?;

        let run_target =
            Self::GUARD_COMMENT.to_string() + "\n" + target_file.as_os_str().to_str().unwrap();

        contents = contents.replace(&run_target, "");
        contents += &run_target;

        fs::write(&profile_file, contents)?;
        fs::write(&target_file, self.source())?;

        Ok(())
    }

    #[cfg(any(target_os = "linux", target_os = "macos"))]
    pub fn uninstall(&self) -> Result<(), io::Error> {
        fs::remove_file(self.target_dir().join(self.file_name()))?;

        Ok(())
    }

    #[cfg(target_os = "windows")]
    pub fn uninstall(&self) -> Result<(), io::Error> {
        let target_dir = self.target_dir();
        let target_file = target_dir.join("dare_completions.ps1");
        let profile_file = target_dir.join(self.file_name());

        let mut contents = fs::read_to_string(&profile_file)?;

        let run_target =
            Self::GUARD_COMMENT.to_string() + "\n" + target_file.as_os_str().to_str().unwrap();

        contents = contents.replace(&run_target, "");

        fs::write(&profile_file, contents)?;
        fs::remove_file(target_file)?;

        Ok(())
    }
}

pub fn get_source(source: Option<String>, path: Option<PathBuf>) -> String {
    match source {
        Some(source) => source,
        None => {
            if let Some(path) = path {
                std::fs::read_to_string(path).expect("Failed to read file")
            } else {
                let mut buffer = String::new();
                io::stdin()
                    .read_to_string(&mut buffer)
                    .expect("Failed to read from stdin");
                buffer
            }
        }
    }
}

pub fn handle_error<T, E>(result: Result<T, E>, message: &str) -> T
where
    E: std::fmt::Display,
{
    match result {
        Ok(result) => result,
        Err(error) => {
            eprintln!("Error: {}\n", error);
            eprintln!("{}", message);
            std::process::exit(1);
        }
    }
}

fn main() {
    let args = Args::parse();

    match args.subcommand {
        SubCommand::Tableau(command) => {
            let source = get_source(command.source, command.path);

            // TODO: proper error reporting
            let tableau = dare::Tableau::parse(&source, !command.expect_false).unwrap();

            let output = match command.format {
                OutputFormat::Latex => {
                    let mut latex = dare::LatexTableauWriter::default();

                    if command.show_all_ids {
                        latex.show_all_ids();
                    }

                    latex.write_tableau(&tableau).unwrap();
                    latex.finalize()
                }
            };

            println!("{}", output);
            if command.clip_board {
                clipboard_set(output);
            }
        }
        SubCommand::Solve(command) => {
            let source = get_source(command.source, command.path);

            let tableau = dare::Tableau::parse(&source, !command.expect_false).unwrap();
            let mut solutions = Solutions::from(&tableau);
            solutions.clean();

            if solutions.is_empty() {
                println!("No solutions found.");
            }

            for (i, solution) in solutions.iter().enumerate() {
                println!("Solution #{}", i);

                for (variable, value) in solution.iter() {
                    let value = if value { "T" } else { "F" };
                    println!("\t{}: {}", variable, value);
                }

                if i < solutions.len() - 1 {
                    println!();
                }
            }
        }
        SubCommand::Complete(command) => match command.subcommand {
            CompleteCommand::Install { shell } => {
                println!("Installing completion for {}", shell);

                handle_error(
                    shell.install(),
                    "Failed to install completion, are you root?",
                );

                println!("Done!");
            }
            CompleteCommand::Uninstall { shell } => {
                println!("Uninstalling completion for {}", shell);

                handle_error(
                    shell.uninstall(),
                    "Failed to uninstall completion, are you root?",
                );

                println!("Done!");
            }
        },
    }
}
